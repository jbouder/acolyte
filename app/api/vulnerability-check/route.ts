import { NextRequest, NextResponse } from 'next/server';

interface VulnerabilityData {
  package: string;
  version: string;
  vulnerabilities: Array<{
    id: string;
    title: string;
    severity: string;
    description: string;
    references: string[];
    affectedVersions: string[];
    patchedVersions: string[];
  }>;
}

interface OSVResponse {
  vulns: Array<{
    id: string;
    summary: string;
    details: string;
    severity: Array<{
      type: string;
      score: string;
    }>;
    references: Array<{
      url: string;
    }>;
    affected: Array<{
      package: {
        ecosystem: string;
        name: string;
      };
      ranges: Array<{
        type: string;
        events: Array<{
          introduced?: string;
          fixed?: string;
        }>;
      }>;
    }>;
  }>;
}

const delay = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));

export async function POST(request: NextRequest) {
  try {
    const { packages } = await request.json();

    if (!packages || !Array.isArray(packages)) {
      return NextResponse.json(
        { error: 'Invalid packages data' },
        { status: 400 },
      );
    }

    const vulnerabilities: VulnerabilityData[] = [];

    // Process packages in batches to avoid rate limiting
    const batchSize = 5;
    for (let i = 0; i < packages.length; i += batchSize) {
      const batch = packages.slice(i, i + batchSize);
      const batchPromises = batch.map(
        async (pkg: { name: string; version: string }) => {
          try {
            // Query OSV database for vulnerabilities
            const osvResponse = await fetch('https://api.osv.dev/v1/query', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                package: {
                  ecosystem: 'npm',
                  name: pkg.name,
                },
                version: pkg.version.replace(/[\^~]/g, ''), // Remove semver prefixes
              }),
            });

            if (!osvResponse.ok) {
              console.warn(`Failed to check vulnerabilities for ${pkg.name}`);
              return null;
            }

            const osvData: OSVResponse = await osvResponse.json();

            if (osvData.vulns && osvData.vulns.length > 0) {
              const packageVulns = osvData.vulns.map((vuln) => ({
                id: vuln.id,
                title: vuln.summary || 'Security vulnerability',
                severity: getSeverityFromScore(vuln.severity),
                description:
                  vuln.details || vuln.summary || 'No description available',
                references: vuln.references?.map((ref) => ref.url) || [],
                affectedVersions:
                  vuln.affected?.flatMap(
                    (a) =>
                      a.ranges?.flatMap((r) =>
                        r.events
                          ?.map((e) => e.introduced || e.fixed)
                          .filter(Boolean),
                      ) || [],
                  ) || [],
                patchedVersions:
                  vuln.affected?.flatMap(
                    (a) =>
                      a.ranges?.flatMap((r) =>
                        r.events?.filter((e) => e.fixed).map((e) => e.fixed!),
                      ) || [],
                  ) || [],
              }));

              return {
                package: pkg.name,
                version: pkg.version,
                vulnerabilities: packageVulns,
              };
            }

            return null;
          } catch (error) {
            console.error(`Error checking ${pkg.name}:`, error);
            return null;
          }
        },
      );

      const batchResults = await Promise.all(batchPromises);
      vulnerabilities.push(
        ...(batchResults.filter(Boolean) as VulnerabilityData[]),
      );

      // Add delay between batches to respect rate limits
      if (i + batchSize < packages.length) {
        await delay(500);
      }
    }

    // Also try npm audit API approach for additional data
    try {
      const npmAuditResponse = await fetch(
        'https://registry.npmjs.org/-/npm/v1/security/audits',
        {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            name: 'temp-audit',
            version: '1.0.0',
            requires: packages.reduce((acc: any, pkg: any) => {
              acc[pkg.name] = pkg.version;
              return acc;
            }, {}),
          }),
        },
      );

      if (npmAuditResponse.ok) {
        const auditData = await npmAuditResponse.json();
        // Process npm audit data and merge with OSV results
        // This would require more complex processing based on npm audit response format
      }
    } catch (error) {
      console.warn('npm audit API failed:', error);
    }

    return NextResponse.json({ vulnerabilities });
  } catch (error) {
    console.error('Vulnerability check error:', error);
    return NextResponse.json(
      { error: 'Failed to check vulnerabilities' },
      { status: 500 },
    );
  }
}

function getSeverityFromScore(
  severity: Array<{ type: string; score: string }> | undefined,
): string {
  if (!severity || severity.length === 0) {
    return 'moderate';
  }

  const cvssScore = severity.find((s) => s.type === 'CVSS_V3');
  if (!cvssScore) {
    return 'moderate';
  }

  const score = parseFloat(cvssScore.score);
  if (score >= 9.0) return 'critical';
  if (score >= 7.0) return 'high';
  if (score >= 4.0) return 'moderate';
  return 'low';
}
